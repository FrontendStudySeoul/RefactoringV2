# 1. 리팩터링: 첫 번째 예시

설계가 나쁜 시스템은 수정하기 어렵다. 원하는 동작을 수행하도록 하기 위해 수정해야 할 부분을 찾고, 기존 코드와 잘 맞물려 작동하게 할 방법을 강구하기 어렵기 때문이다. 무엇을 수정할지 어렵다면 실수를 저질러서 버그가 생길 가능성도 높아진다.

**프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다.**

**리팩터링이 필요한 이유는 변경 때문이다.** 잘 작동하고 나중에 변경할 일이 절대 없다면 코드를 현재 상태로 나둬도 아무런 문제가 없다. 더 다듬어주면 물론 좋겠지만, 누군가 코드를 읽지 않는 한 아무런 피해가 없다. but 그러다 다른 사람이 읽고 이해해야 할 일이 생겼는데 로직을 파악하기 어렵다면 뭔가 대책을 마련해야 한다.

## 1.3 리팩터링의 첫 단계
먼저, 리팩터링할 코드 영역을 꼼꼼하게 검사해줄 테스트 코드부터 마련해야 한다. 리팩터링에서 테스트의 역할은 굉장히 중요하다. 리팩터링 기법들이 버그 발생 여지를 최소화하도록 구성됐다고는 하나 실제 작업은 사람이 수행하기 때문에 언제든 실수할 수 있다. 프로그램이 클 수록 수정 과정에서 예상치 못한 문제가 발생할 가능성이 높다.

**리팩터링하기 전에 제대로 된 테스트부터 마련한다. 테스트는 반드시 자가진단하도록 만든다.**

필자는 리팩터링 시 테스트에 상당히 의지한다. 저지른 실수로부터 보호해주는 버그 검출기 역할을 해주기 때문이다. **테스트를 작성하는 데 시간이 좀 걸리지만, 신경 써서 만들어두면 디버깅 시간이 줄어서 전체 작업 시간은 오히려 단축된다.**

간단한 수정이라도 리팩터링 후에는 항상 테스트하는 습관을 들이는 것이 바람직히다. 사람은 실수하기 마련이다. 한 가지를 수정할 때마다 테스트하면, 오류가 생기더라도 변경 폭이 작기 때문에 살펴볼 범위도 좁아서 문제를 찾고 해결하기가 훨씬 쉽다. 이처럼 조금씩 변경하고 매번 테스트하는 것은 리팩터링 절차의 핵심이다. 한 번에 너무 많이 수정하려다 실수를 저지르면 디버깅하기 어려워서 결과적으로 작업 시간이 늘어난다. 조금씩 수정하여 피드백 주기를 짧게 가져가는 습관이 이러한 재앙을 피하는 길이다.

**리팩터링은 프로그램 수정을 작은 단계로 나눠 진행한다. 그래서 중간에 실수하더라도 버그를 쉽게 찾을 수 있다.**

코드를 파악해서 얻은 정보는 휘발성이 높기로 악명 높은 저장 장치인 내 머릿속에 기록되므로, 잊지 않으려면 재빨리 코드에 반영해야 한다.

###  컴퓨터가 이해하는 코드는 바보도 작성할 수 있다. 사람이 이해하도록 작성하는 프로그래머가 진정한 실력자다.

좋은 코드라면 하는 일이 명확히 드러나야 하며, 이때 변수 이름은 커다한 역할을 한다. 그러니 명확성을 높이기 위한 이름 바꾸기에는 조금도 망설이지 말기 바란다.

리팩터링을 하다보면 성능이 안좋아질 수 있다. 설사 심각하게 느려지더라도 제대로 리팩터링된 코드베이스는 그렇지 않은 코드보다 성능을 개선하기가 훨씬 수월하다.

### 지역 변수 제거하기

지역 변수를 제거해서 얻는 가장 큰 장점은 추출 작업이 훨씬 쉬워진다는 것이다. 유효범위를 신경 써야 할 대상이 줄어들기 때문이다. 실제로 추출 작업 전에는 거의 항상 지역 변수부터 제거한다.

임시 변수는 문제를 일으킬 수 있다. 임시 변수는 자신이 속한 루틴에서만 의미가 있어서 루틴이 길고 복잡해지기 쉽다. 따라서 다음으로 할 리팩터링은 이런 변수를 제거하는 것이다.

### 이름 짓기
이름 짓기는 중요하면서도 쉽지 않은 작업이다. 긴 함수를 작게 쪼개는 리팩터링은 이름을 잘 지어야만 효과가 있다. 이름이 좋으면 함수 본문을 읽지 않고도 무슨 일을 하는지 알 수 있다. 물론 단번에 좋은 이름을 짓기는 쉽지 않다. 따라서 처음에는 당장 떠오르는 최선의 이름을 사용하다가, 나중에 더 좋은 이름이 떠오를 때 바꾸는 식이 좋다. 흔히 코드를 두 번 이상 읽고 나서야 적합한 이름이 떠오르곤 한다.

### 리팩터링과 성능
반복문을 쪼개서 성능이 느려지지 않을까 걱정할 수 있다.(함수로 만들었기 때문에 인라인에서 호출하면 반복문을 여러 번 호출할 수 있기 때문.) 이처럼 반복문이 중복되는 것을 꺼리는 이들이 많지만, 이 정도 중복은 성능에 영향이 미미할 때가 많다. 실제로 이번 리팩터링 전과 후의 실제 성능을 정확히 예측하지 못한다. 똑똑한 컴파일러들은 최신 캐싱 기법 등으로 무장하고 있어서 우리의 직관을 초월하는 결과를 내어주기 때문이다. 또한 소프트웨어 성능은 대체로 코드의 몇몇 작은 부분에 의해 결정되므로 그 외의 부분은 수정한다고 해도 성능 차이를 체감할 수 없다.

but 대체로 그렇다와 항상 그렇다는 엄연히 다르다. 때로는 리팩터링이 성능에 상당한 영향을 주기도 한다. 잘 다듬어진 코드라야 성능 개선 작업도 훨씬 수월하기 때문이다. 리팩터링 과정에서 성능이 크게 떨어졌다면 리팩터링 후 시간을 내어 성능을 개선한다. 이 과정에서 리팩터링된 코드를 예전으로 되돌리는 경우도 있지만, 대체로 리팩터링 덕분에 성능 개선을 더 효과적으로 수행할 수 있다. 결과적으로 더 깔끔하면서 더 빠른 코드를 얻게 된다.

따라서 리팩터링으로 인한 성능 문제에 대한 필자의 조언은 **특별한 경우가 아니라면 일단 무시하라**는 것이다. 리팩터링 때문에 성능이 떨어진다면, 하던 리팩터링을 마무리하고 나서 성능을 개선하자.

### 리팩터링 순서
기본적으로 **컴파일-테스트-커밋** 과정으로 진행한다.

1. **반복문 쪼개기**로 변수 값을 누적시키는 부분을 관리한다.
2. **문장 슬라이드하기**로 변수 초기화 문장을 변수 값 누적 코드 바로 앞으로 옮긴다.
3. **함수 추출하기**로 별도 함수로 추출한다.
4. **변수 인라인하기**로 변수를 제거한다.

상황이 복잡해지면 단계를 더 작게 나누는 일을 가장 먼저 한다. 특히 리팩터링 중간에 테스트가 실패하고 원인을 바로 찾지 못하면 가장 최근 커밋으로 돌아가서 테스트에 실패한 리팩터링의 단계를 더 작게 나눠 다시 시도한다. 이렇게 하면 문제를 해결할 수 있다. 커밋을 자주 했기 때문이기도 하고, 코드가 복잡할수록 단계를 작게 나누면 작업 속도가 빨라지기 때문이다.
