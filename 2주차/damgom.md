## 다형성을 활용해 계산 코드 재구성하기

- 목표
  - 연극 장르 추가
  - 장르마다 공연료와 적립 포인트 계산법을 다르게 설정

- 문제점
  - `amountFor()`: 조건부 로직
  - 조건부 로직은 수정 횟수가 늘어남에 따라 문제를 일으키기 쉽다

- 해결 방법
  - 프로그래밍 언어가 제공하는 구조적인 요소로 보완
  - class를 이용
    - 리팩토링: 공연료에 관한 계산을 실행해 주는 객체를 만들고 각 조건 (비극, 희극)에 따라 서브 클래스를 생성하면서 원하는 계산값을 반
    - 장르 추가에 따라 로직을 추가해야할 경우에는 팩토리 함수에 장르 케이스를 추가하고 서브클래스에서 메서드를 오버라이딩

---

1. 상속 계층 정의
   1. 상속 계층 클래스 작성
       - 두 장르가 모두 필요로 하는 공연료, 적립 포인트 계산 함수를 담는 클래스를 작성
   2. 상속 계층 클래스로 함수 옮기기

2. 타입 코드를 서브클래스로 바꾸기
   - 계산기 클래스를 상속하는 비극 공연 계산기, 희극 공연 계산기 서브 클래스를 작성

3. 조건부 로직을 다형성으로 바꾸기
   - 슈퍼 클래스의 계산 로직을 오버라이드 하도록 각 장르에 필요한 계산 코드를 담은 메서드를 서브 클래스에 정의
   - 공통되는 일반적인 계산은 슈퍼 클래스에 정의, 장르마다 달라지는 부분만 오버라이드
  
---

## 다형성
- 객체 지향: 캡슐화, 상속, 추상화, 다형성
  - 캡슐화: 하나의 캡슐로 만들어 데이터를 외부로부터 보호
  - 상속: 객체의 일부분만 재사용, 객체의 공통된 부분만 따로 만들어서 상속받아서 활용
  - 추상화: 공통 부분을 모아서 추출
  - 다형성: 하나의 기능이 여러가지 형태를 가질 수 있는 성질


- 자바스크립트의 객체 지향: 프로토타입을 기반으로 캡슐화, 추상화, 다형성, 상속 구현 가능


  > #### [프로토타입](https://developer.mozilla.org/ko/docs/Learn/JavaScript/Objects/Classes_in_JavaScript)
  > ``` js
  > function Cat(name, age) {
  >     this.name = name;
  >     this.age = age;
  > };
  >
  > Cat.prototype.makeNoise = function() {
  >     console.log('Meow!');
  > }
  >
  > const cake = new Cat('Cake', 3);
  >
  > cake.makeNoise(); // 'Meow!'
  > ```
  >
  > #### 클래스
  > - ES6에 클래스 문법이 추가되면서 간결하게 객체지향 프로그래밍을 할 수 있게 되었다.
  > ``` js
  > // Animal.js
  > class Animal {
  >
  > }
  > 
  > export default Animal;
  > ```



### 오버라이딩

``` js
// 슈퍼 클래스
get amount() {
  switch (this.play.type) { ... }
}

// 서브 클래스
get amount() {
 // 슈퍼클래스의 조건부 로직 중 서브 클래스에 해당하는 부분
}
```
