## 3. 코드에서 나는 악취

### 3.1 기이한 이름
- 코드는 단순하고 명료하게 작성해야한다
  - 이름만 잘 지어도 나중에 문맥을 파악하느라 헤매는 시간을 크게 절약할 수 있다
- 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다
- 혼란스러운 이름을 잘 정리하다 보면 코드가 훨씬 간결해질 때가 많다.

### 3.2 중복 코드
- 코드가 중복되면 각각을 볼 때마다 서로 차이점은 없는지 주의 깊게 살펴봐야 하는 부담이 생긴다.

### 3.3 긴 함수
- 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오는 것
- 좋은 이름 짓기: 짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다. 
   -  함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다.
   -  **함수의 목적**이 드러나게 이름을 지어야한다
- 함수 추출하기: 코드가 단 한 줄이어도 따로 설명할 필요가 있다면 함수로 추출하는 게 좋다.
  - 매개변수 객체 만들기 / 객체 통째로 넘기기
  - 함수가 여러개의 목적을 갖고 있지는 않은지 확인하고 쪼개는 일을 먼저한다.

### 3.4 긴 매개변수 목록
- 문제점: 매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많다
- 매개변수 목록이 길어지면 꼭 필요한 데이터인지, 혹 그렇다면 객체로 넘기는 것이 명확하지는 않을지 고민한다.
- 클래스는 매개변수 목록을 줄이는데 효과적이다
  - 여러개의 함수가 특정 매개변수들의 값을 공통으로 사용할 때 유용 

### 3.5 전역 데이터
- 문제점: 전역 데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없다
  - 전역 데이터가 가변이라면 특히나 다루기 까다롭다.
- 해결 방법: 변수 캡슐화
  - 데이터를 함수를 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾고 접근을 통제할 수 있다  

### 3.6 가변 데이터
- 코드의 다른 곳에서는 다른 값을 기대한다는 사실을 인식하지 못한 채 수정해버리면 프로그램이 오작동
- 변수의 유효범위가 단 몇 줄뿐이라면 가변 데이터라 해도 문제를 일으킬 일이 별로 없다.
- 변수를 갱신하는 코드들의 유효범위를 제한한다.

### 3.7 뒤엉킨 변경
- 뒤엉킨 변경은 단일 책임 원칙이 제대로 지켜지지 않을 때 나타난다.
- 예컨데 지원해야 할 데이터베이스가 추가될 때마다 함수 세 개를 바꿔야 하고, 금융 상품이 추가될 때마다 또 다른 함수 네 개를 바꿔야 하는 모듈이 있다면 뒤엉킨 변경이 발생했다는 뜻이다.
- 해결 방법: 맥락에 맞게 단계를 분리한 후 클래스 추출을 통해 클래스의 동작을 분할

### 3.8 산탄총 수술
- 이 냄새는 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 풍긴다. 변경할 부분이 코드 전반에 퍼져 있다면 찾기도 어렵고 꼭 수정해야 할 곳을 지나치기 쉽다.
- 해결 방법: 함께 변경되는 대상들을 모두 한 모듈에 묶어두면 좋다.

### 3.9 기능 편애
- 기능 편애는 흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용할 일이 더 많을 때 풍기는 냄새다.
- 해결 방법: 함수를 데이터 근처로 옮긴다

### 3.10 데이터 뭉치
- 데이터 항목 서너 개가 여러 곳에서 항상 함께 뭉쳐 다니는 모습을 흔히 목격할 수 있다. 클래스 두어 개의 필드에서, 혹은 여러 메서드의 시그니처에서 함께 발견되기도 한다.
- 이렇게 몰려다니는 데이터 뭉치는 보금자리를 따로 마련해줘야 마땅하다.

### 3.11 기본형 집착
- 프로그래머 중에는 자신에게 주어진 문제에 딱 맞는 기초 타입(화폐, 좌표, 구간 등)을 직접 정의하기를 몹시 꺼리는 사람이 많다.
- 그래서 금액을 그냥 숫자형으로 계산하거나, 물리량을 계산할 때도 밀리미터나 인치 같은 단위를 무시하고, 범위도 `if (a < upper && a > lower)`처럼 처리하는 코드를 수없이 봤다.

### 3.12 반복되는 switch 문
- 중복된 switch문이 문제가 되는 이유는 조건절을 하나 추가할 때마다 다른 switch문들도 모두 찾아서 함께 수정해야 하기 때문이다.
- 해결 방법: 다형성
  - 다형성은 반복된 switch문이 내뿜는 사악한 기운을 제압하여 코드베이스를 최신 스타일로 바꿔주는 세련된 무기인 셈이다.

### 3.13 반복문
- filter, map

### 3.14 성의 없는 요소
- 그대로 쓰는 것과 다를바 없는 함수, 실질적으로 메서드가 하나뿐ㅇㄴ 클래스

### 3.15 추측성 일반화
-  '나중에 필요할 거야'라는 생각으로 당장은 필요 없는 모든 종류의 후킹 포인트와 특이 케이스 처리 로직을 작성해둔 코드

### 3.16 임시 필드
- 특정 상황에서만 사용되는 필드를 가진 클래스
- 해결 방법: 클래스로 추출하거나 null 처리 대안 클래스

### 3.17 메세지 체인
- 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식으로, 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드
- 객체 사용자가 객체 내비게이션 구조에 종속됐음을 의미
- 해결 방법: 위임 숨기기
  - 최종 개체가 사용되는 이유를 생각해보면 기능을 추출하여 체인의 시작 부분으로 이동하는 것이 합리적

### 3.18 중개자
- 클래스가 다른 클래스에 작업을 위임하는 역할만 하는 경우
- 해결 방법: 실제로 일을 하는 객체와 직접 소통하기

### 3.19 내부자 거래
- 은밀히 데이터를 주고받는 모듈들이 있다면 떼어놓아서 사적으로 처리하는 부분을 줄인다.

### 3.20 거대한 클래스
- 문제점: 한 클래스가 너무 많을 일을 하려다 보면 필드 수가 상당히 늘어난다.
  - 클래스에 필드가 너무 많으면 중복 코드가 생기기 쉽다
- 해결방법: 한 컴포넌트에 모아두는 것이 합당에 보이는 필드들을 묶어 슈퍼클래스로 추출

### 3.21 서로 다른 인터페이스의 대안 클래스들 
- 클래스를 사용할 때의큰 장점은 필요에 따라 언제든 다른 클래스로 교체할 수 있다는 것이다. 교체하려면 인터페이스가 같아야 한다.

### 3.22 데이터 클래스
- 데이터 클래스: 데이터 필드와 게터/세터 메서드로만 구성된 클래스
- 문제점: 데이터 저장 용도로만 쓰이다 보니 다른 클래스가 너무 깊이까지 함부로 다룰 때가 많다
- 해결 방법: public 필드가 있다면 누가 보기 전에 얼른 레코드 캡슐화하기로 숨기자. 변경하면 안되는 필드는 세터 제거하기로 접근을 원천 봉쇄

### 3.23 상속 포기
- 상속 포기 냄새는 서브클래스가 부모의 동작은 필요로하지만 인터페이스는 따르고 싶지 않을 때 특히 심하게 난다.
- 해결 방법: 위임을 활용해서 아예 상속 메커니즘에서 벗어나보자.

### 3.24 주석
- 주석은 악취가 아닌 향기를 입힌다. 문제는 주석을 탈취제처럼 사용하는 데 있다. 주석이 장황하게 달린 원인이 코드를 잘못 작성했기 때문인 경우가 의외로 많다.
- 주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링해본다. 
